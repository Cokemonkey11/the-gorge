package Ai

import ErrorHandling
import HashMap
import LinkedListModule
import Ships
import TerrainData

bool array ai_controlled

constant UPDATE_PERIOD = 1.

class Vec2
    vec2 v
    construct(vec2 which)
        this.v = which

constant aiMap = new HashMap<string, Vec2>()

public enum Propensity
    None
    North
    South

function Propensity.toString() returns string
    switch this
        case North
            return "North"
        case South
            return "South"
        default
            error("Bad propensity to make into string")
            return ""

public enum Status
    None
    OwnTower
    Obelisk
    EnemyTower
    EnemyKeep

function Status.next() returns Status
    switch this
        case OwnTower
            return Status.Obelisk
        case Obelisk
            return Status.EnemyTower
        case EnemyTower
            return Status.EnemyKeep
        case EnemyKeep
            return Status.EnemyKeep
        default
            error("Unexpected Status")
            return Status.None

function Status.toString() returns string
    switch this
        case OwnTower
            return "OwnTower"
        case Obelisk
            return "Obelisk"
        case EnemyTower
            return "EnemyTower"
        case EnemyKeep
            return "EnemyKeep"
        default
            error("Base Status to display")
            return ""

function Status.toVec2(Propensity p, player alliance) returns vec2
    let key = this.toString() + p.toString() + alliance.getName()
    if aiMap.has(key)
        return aiMap.get(key).v

    switch alliance.getId()
        case 0  // West team
            switch p
                case North
                    switch this
                        case OwnTower
                            aiMap.put(key, new Vec2(TerrainData.POS_TOWER_WEST_NORTH))
                            return this.toVec2(p, alliance)
                        case Obelisk
                            aiMap.put(key, new Vec2(TerrainData.POS_STONE1))
                            return this.toVec2(p, alliance)
                        case EnemyTower
                            aiMap.put(key, new Vec2(TerrainData.POS_TOWER_EAST_NORTH))
                            return this.toVec2(p, alliance)
                        case EnemyKeep
                            aiMap.put(key, new Vec2(TerrainData.POS_KEEP_EAST))
                            return this.toVec2(p, alliance)
                        default
                            error("Tried to get the target for an improper status.")
                case South
                    switch this
                        case OwnTower
                            aiMap.put(key, new Vec2(TerrainData.POS_TOWER_WEST_SOUTH))
                            return this.toVec2(p, alliance)
                        case Obelisk
                            aiMap.put(key, new Vec2(TerrainData.POS_STONE2))
                            return this.toVec2(p, alliance)
                        case EnemyTower
                            aiMap.put(key, new Vec2(TerrainData.POS_TOWER_EAST_SOUTH))
                            return this.toVec2(p, alliance)
                        case EnemyKeep
                            aiMap.put(key, new Vec2(TerrainData.POS_KEEP_EAST))
                            return this.toVec2(p, alliance)
                        default
                            error("Tried to get the target for an improper status.")
                default
                    error("Tried to get the target without a propensity.")
        case 1  // East team
            switch p
                case North
                    switch this
                        case OwnTower
                            aiMap.put(key, new Vec2(TerrainData.POS_TOWER_EAST_NORTH))
                            return this.toVec2(p, alliance)
                        case Obelisk
                            aiMap.put(key, new Vec2(TerrainData.POS_STONE1))
                            return this.toVec2(p, alliance)
                        case EnemyTower
                            aiMap.put(key, new Vec2(TerrainData.POS_TOWER_WEST_NORTH))
                            return this.toVec2(p, alliance)
                        case EnemyKeep
                            aiMap.put(key, new Vec2(TerrainData.POS_KEEP_WEST))
                            return this.toVec2(p, alliance)
                        default
                            error("Tried to get the target for an improper status.")
                case South
                    switch this
                        case OwnTower
                            aiMap.put(key, new Vec2(TerrainData.POS_TOWER_EAST_SOUTH))
                            return this.toVec2(p, alliance)
                        case Obelisk
                            aiMap.put(key, new Vec2(TerrainData.POS_STONE2))
                            return this.toVec2(p, alliance)
                        case EnemyTower
                            aiMap.put(key, new Vec2(TerrainData.POS_TOWER_WEST_SOUTH))
                            return this.toVec2(p, alliance)
                        case EnemyKeep
                            aiMap.put(key, new Vec2(TerrainData.POS_KEEP_WEST))
                            return this.toVec2(p, alliance)
                        default
                            error("Tried to get the target for an improper status.")
                default
                    error("Tried to get the target without a propensity.")
        default
            error("Tried to get the target for a non-team player.")
    return vec2(0., 0.)

class CreepAi
    use LinkedListModule

    static timer t = CreateTimer()

    unit u
    Propensity p
    Status s

    function tick()
        let target = this.s.toVec2(
            this.p,
            this.u.getOwner()
        )
        if this.u.getPos().distanceToSq(target) < 500. * 500.
            this.s = this.s.next()
        else
            this.u.issuePointOrder(
                "attack",
                this.u.getPos().moveTowards(target, 500.)
            )

    static function periodic()
        let iter = CreepAi.iterator()
        while iter.hasNext()
            let inst = iter.next()
            if inst.u != null and inst.u.isAlive()
                inst.tick()
            else
                destroy inst

        iter.close()
        if CreepAi.size == 0
            CreepAi.t.pause()

    construct(unit u, Propensity p)
        this.u = u
        this.p = p
        this.s = Status.OwnTower

        tick()

        if CreepAi.size == 1
            CreepAi.t.startPeriodic(UPDATE_PERIOD, function CreepAi.periodic)

public function unit.intoCreepAi(Propensity p)
    new CreepAi(this, p)

function lockShip(unit u)
    u..setPos(u.getOwner().getStartLocation())
        ..setInvulnerable(true)
        ..pause()

public function unit.aiOnRevive()
    if ai_controlled[this.getOwner().getId()]
        lockShip(this)

public function player.intoAi()
    ai_controlled[this.getId()] = true

    // Just lock the ship at the start location.
    let u = Ships.ships[this.getId()]
    if not u == null and u.isAlive()
        lockShip(u)

// Creating a crew member: Create necessary phoenix fire abilities, create
// necessary crew member unit, create necessary cargo unit, add crew member
// unit to keep slot, link member + cargo in this script.
package Crewmembers
	import ClosureTimers
	import Ships
	import Game
	import HashMap
	import SimError
	import RegisterEvents
	import TerrainData

	constant MAX_SLOTS = 10

	class CrewMember
		int ownerID
		unit dummy
		unit phoenix

	class CrewInventory
		CrewMember array[MAX_SLOTS] slots


	public class Crewmembers
		static constant HEADHUNTER_ID    = 'o000'
		static constant HEADHUNTER_D_ID  = 'o009'

		static constant WITCHDOCTOR_ID   = 'o001'
		static constant WITCHDOCTOR_D_ID = 'o00F'

		static constant SPEARMAN_ID      = 'o002'
		static constant SPEARMAN_D_ID    = 'o00D'

		static constant UNBROKEN_ID      = 'o003'
		static constant UNBROKEN_D_ID    = 'o00E'

		static constant SHAMAN_ID        = 'o004'
		static constant SHAMAN_D_ID      = 'o00C'

		static constant SEAWITCH_ID      = 'o005'
		static constant SEAWITCH_D_ID    = 'o00B'

		static constant GRENADIER_ID     = 'o006'
		static constant GRENADIER_D_ID   = 'o008'

		static constant LASERRIFLE_ID    = 'o007'
		static constant LASERRIFLE_D_ID  = 'o00A'

		static constant GRYPHON_ID       = 'o00G'
		static constant GRYPHON_D_ID     = 'o00H'

		static constant AMASTER_ID       = 'o00I'
		static constant AMASTER_D_ID     = 'o00J'

		static constant ODRAKE_ID        = 'o00K'
		static constant ODRAKE_D_ID      = 'o00L'

		static constant VTEMPT_ID        = 'o00M'
		static constant VTEMPT_D_ID      = 'o00N'

		private static constant ERROR_MESSAGE = "You cannot purchase crewmen from your opponent."
		private static constant OFFSET = 256. + 64.
		private static constant SELL_RATE = .5

		private static CrewMember array db
		private static int dbIndex = -1
		private static timer time = CreateTimer()
		static constant fromDummy = new HashMap<unit, CrewMember>()
		static constant links = new HashMap<int, int>()
		static CrewInventory array inventories
		static int array slotIndices

		static function getMemberIndex(int id, CrewMember cre) returns int
			for index = 0 to slotIndices[id]
				if inventories[id].slots[index] == cre
					return index

			return -1


		static function updatePosition(CrewMember cre, int index)
			let face = I2R(index) * 2. * bj_PI / I2R(MAX_SLOTS)
			let x = GetStartLocationX(cre.ownerID) + OFFSET*Cos(face)
			let y = GetStartLocationY(cre.ownerID) + OFFSET*Sin(face)
			SetUnitPosition(cre.dummy, x, y)
			SetUnitFacing(cre.dummy, face*bj_RADTODEG)


		static function release(unit u)
			if fromDummy.has(u)
				let temp = fromDummy.get(u)
				let val = R2I(GetWidgetLife(temp.phoenix)*SELL_RATE)
				players[temp.ownerID].addGold(val)
				printTimedToPlayer(
					"You pawned your |cffffcc00"
						+ GetUnitName(u)
						+ "|r for |cffffcc00"
						+ I2S(val)
						+ "|r gold.",
					10.,
					players[temp.ownerID]
				)
				let index = getMemberIndex(temp.ownerID, temp)
				if index != -1
					inventories[temp.ownerID].slots[index] = inventories[temp.ownerID].slots[slotIndices[temp.ownerID]]
					slotIndices[temp.ownerID]--
					if slotIndices[temp.ownerID] != -1
						updatePosition(inventories[temp.ownerID].slots[index], index)

					temp.dummy.remove()
					temp.phoenix.remove()
					destroy temp
				else
					BJDebugMsg("Error: tried to release a unit that had no index :(")

			else
				BJDebugMsg("Error: Tried to release a unit that wasn't logged :(")

		static function p()
			var index = 0

			while index <= dbIndex
				let temp = db[index]

				if Ships.ships[temp.ownerID].isAlive() and not Game.ended
					temp.phoenix.setPos(Ships.ships[temp.ownerID].getPos())
				else
					temp.phoenix.setPos(TerrainData.SAFE)

				index++

		static function c()
			let selU = GetSellingUnit()
			let bU = GetBuyingUnit()
			let sU = GetSoldUnit()
			let buyer = GetOwningPlayer(sU)

			if Ships.getClass(sU) == Ships.CLASS_UNKNOWN
				if IsUnitAlly(bU, GetOwningPlayer(selU))
					let temp = new CrewMember
					temp.ownerID = GetPlayerId(buyer)
					slotIndices[temp.ownerID]++
					inventories[temp.ownerID].slots[slotIndices[temp.ownerID]] = temp
					let face = I2R(slotIndices[temp.ownerID]) * 2. * bj_PI / I2R(MAX_SLOTS)
					let x = GetStartLocationX(temp.ownerID) + OFFSET*Cos(face)
					let y = GetStartLocationY(temp.ownerID) + OFFSET*Sin(face)
					temp.dummy = createUnit(buyer, links.get(sU.getTypeId()), vec2(x, y), angle(face))
					PingMinimapForPlayer(buyer, x, y, 5.)
					temp.phoenix = sU
					dbIndex++
					db[dbIndex] = temp
					fromDummy.put(temp.dummy, temp)

					if dbIndex == 0
						TimerStart(time, ANIMATION_PERIOD, true, function p)

				else
					simError(GetOwningPlayer(bU), ERROR_MESSAGE)
					buyer.addGold(sU.getLife().toInt())
					sU.remove()

	init
		registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SELL, function Crewmembers.c)

		// Format Links
		Crewmembers.links.put(Crewmembers.HEADHUNTER_ID,  Crewmembers.HEADHUNTER_D_ID)
		Crewmembers.links.put(Crewmembers.WITCHDOCTOR_ID, Crewmembers.WITCHDOCTOR_D_ID)
		Crewmembers.links.put(Crewmembers.SPEARMAN_ID,    Crewmembers.SPEARMAN_D_ID)
		Crewmembers.links.put(Crewmembers.UNBROKEN_ID,    Crewmembers.UNBROKEN_D_ID)
		Crewmembers.links.put(Crewmembers.SHAMAN_ID,      Crewmembers.SHAMAN_D_ID)
		Crewmembers.links.put(Crewmembers.SEAWITCH_ID,    Crewmembers.SEAWITCH_D_ID)
		Crewmembers.links.put(Crewmembers.GRENADIER_ID,   Crewmembers.GRENADIER_D_ID)
		Crewmembers.links.put(Crewmembers.LASERRIFLE_ID,  Crewmembers.LASERRIFLE_D_ID)
		Crewmembers.links.put(Crewmembers.GRYPHON_ID,     Crewmembers.GRYPHON_D_ID)
		Crewmembers.links.put(Crewmembers.AMASTER_ID,     Crewmembers.AMASTER_D_ID)
		Crewmembers.links.put(Crewmembers.ODRAKE_ID,      Crewmembers.ODRAKE_D_ID)
		Crewmembers.links.put(Crewmembers.VTEMPT_ID,      Crewmembers.VTEMPT_D_ID)

		// Initialize slotInidices
		for index = 0 to 11
			Crewmembers.slotIndices[index] = -1

		// Initialize CrewInventories
		for index = 0 to 11
			Crewmembers.inventories[index] = new CrewInventory()

		let text = createTTEx(
			TerrainData.POS_KEEP_EAST.withTerrainZ(),
			"Buy weapons here",
			10.
		)

		let text2 = createTTEx(
			TerrainData.POS_KEEP_WEST.withTerrainZ(),
			"Buy weapons here",
			10.
		)

		let offset = vec3(-100., 0., 0)
		doPeriodicallyCounted(
			ANIMATION_PERIOD,
			(45. / ANIMATION_PERIOD).toInt()
		) (CallbackCounted cb) ->
			if cb.isLast()
				text.destr()
				text2.destr()
			else
				let base_ = (
					8. * (cb.getCount().toReal() * ANIMATION_PERIOD) / (2. * PI)
				).cos()

				text.setPos(
					TerrainData.POS_KEEP_EAST.withTerrainZ(
						50. * (base_ * base_)
					) + offset
				)
				text2.setPos(
					TerrainData.POS_KEEP_WEST.withTerrainZ(
						50. * (base_ * base_)
					) + offset
				)

// Helicopter (Frigate) Q Ability:
// Fires two missiles at a unit, which accelerate towards the target and deal
// damage upon contact. If the missiles do not hit they eventually disjoint.
// If a location is targeted, the missiles instead accelerate in one direction.
// This ability can be cast twice before it will enter cooldown.
// 		Damage (each):    55
//	    Cast Range:       700
//		Maximum Range:    1800
//	    Initial Velocity: 600
//		Maximum Velocity: 1200
//		Acceleration:     100

package DTS12MissileArray
	import Game
	import RegisterPlayerUnitEvent
	import DamageType
	import Ships
	import Sounds
	import ClosureTimers

	native UnitAlive takes unit u returns boolean

	struct Missile
		unit target
		real dX
		real dY
		real ddX = 0.
		real ddY = 0.
		real vel
		real dist= 0.
		unit missile
		integer ownerID
		effect fx
	end

	public class DTS12MissileArray
		static constant integer DUMMY_ID = 'u000'
		static constant integer ARRAY_ID = 'A00P'
		static constant real DAMAGE           = 55.
		static constant real MAXIMUM_RANGE    = 1800.
		static constant real INITIAL_VELOCITY = 600.
		static constant real MAXIMUM_VELOCITY = 1200.
		static constant real INITIAL_OFFSET   = 24.
		static constant real ACCELERATION     = 100.
		static constant real CLOCK_PERIOD     = 1./30.
		static constant real COLLISION_RADIUS = 32.+64.
		static constant real FLY_HEIGHT       = 120.
		static constant real CHEAP_FRICTION   = MAXIMUM_VELOCITY / (MAXIMUM_VELOCITY + ACCELERATION)
		static constant real SCALE = .75
		static constant string MISSILE_MODEL = "Abilities\\Weapons\\RocketMissile\\RocketMissile.mdl"
		static constant string SOUND         = "Abilities\\Spells\\Human\\FlakCannons\\FlakCannon.wav"

		static timer clock = CreateTimer()
		static Missile array db
		static integer dbIndex = -1
		static location loc = Location(0., 0.)
		static group grp = CreateGroup()
		static Table ht

		static function getZ takes real x, real y returns real
			MoveLocation(loc, x, y)
			return GetLocationZ(loc)
		end

		static function disjoint takes unit u returns nothing
			integer index = 0
			Missile temp
			loop
				exitwhen index>dbIndex
				temp = db[index]
				if temp.target == u then
					temp.target = null
				end
				index= index+1
			endloop
		end

		static function p takes nothing returns nothing
			integer index = 0
			Missile temp
			real ang
			unit first
			boolean hit
			real newX
			real newY
			real oldX
			real oldY
			loop
				exitwhen index>dbIndex
				temp = db[index]
				if temp.target== null then
					temp.dX = temp.dX + temp.ddX
					temp.dY = temp.dY + temp.ddY
					temp.dX = (1 - CHEAP_FRICTION*CLOCK_PERIOD) * temp.dX
					temp.dY = (1 - CHEAP_FRICTION*CLOCK_PERIOD) * temp.dY
					oldX = GetUnitX(temp.missile)
					oldY = GetUnitY(temp.missile)
					newX = oldX+temp.dX
					newY = oldY+temp.dY
					SetUnitX(temp.missile, newX)
					SetUnitY(temp.missile, newY)
					SetUnitFlyHeight(temp.missile, GetUnitFlyHeight(temp.missile)-(getZ(newX, newY)-getZ(oldX, oldY)), 0.)
					temp.vel = temp.vel + ACCELERATION * CLOCK_PERIOD
					temp.vel = (1 - CHEAP_FRICTION*CLOCK_PERIOD) * temp.vel
					temp.dist = temp.dist + temp.vel
					GroupEnumUnitsInRange(grp, newX, newY, COLLISION_RADIUS, null)
					hit = false
					loop
						first= FirstOfGroup(grp)
						exitwhen first== null
						if IsUnitEnemy(first, Game.players[temp.ownerID]) and UnitAlive(first) and IsUnitType(first, UNIT_TYPE_STRUCTURE)== false and not hit then
							hit = true
							DamageType.dealCodeDamage(Ships.ships[temp.ownerID], first, DAMAGE)
						end
						GroupRemoveUnit(grp, first)
					endloop
					if temp.dist >= MAXIMUM_RANGE or hit then
						KillUnit(temp.missile)
						DestroyEffect(temp.fx)
						db[index] = db[dbIndex]
						dbIndex = dbIndex - 1
						index = index -1
						destroy temp
						if dbIndex== -1 then
							PauseTimer(clock)
						end
					end
				else
					ang = Atan2(GetUnitY(temp.target)-GetUnitY(temp.missile), GetUnitX(temp.target)-GetUnitX(temp.missile))
					SetUnitFacing(temp.missile, ang*bj_RADTODEG)
					temp.ddX = ACCELERATION * CLOCK_PERIOD * Cos(ang)
					temp.ddY = ACCELERATION * CLOCK_PERIOD * Sin(ang)
					temp.dX = temp.dX + temp.ddX
					temp.dY = temp.dY + temp.ddY
					temp.dX = (1 - CHEAP_FRICTION*CLOCK_PERIOD) * temp.dX
					temp.dY = (1 - CHEAP_FRICTION*CLOCK_PERIOD) * temp.dY
					newX = GetUnitX(temp.missile)+temp.dX
					newY = GetUnitY(temp.missile)+temp.dY
					SetUnitX(temp.missile, newX)
					SetUnitY(temp.missile, newY)
					temp.vel = SquareRoot(temp.dX*temp.dX + temp.dY*temp.dY)
					temp.dist = temp.dist + temp.vel
					if not UnitAlive(temp.target) then
						temp.target = null
					end
					GroupEnumUnitsInRange(grp, newX, newY, COLLISION_RADIUS, null)
					hit = false
					loop
						first= FirstOfGroup(grp)
						exitwhen first== null
						if IsUnitEnemy(first, Game.players[temp.ownerID]) and UnitAlive(first) and IsUnitType(first, UNIT_TYPE_STRUCTURE)== false and not hit then
							hit = true
							DamageType.dealCodeDamage(Ships.ships[temp.ownerID], first, DAMAGE)
						end
						GroupRemoveUnit(grp, first)
					endloop
					if temp.dist >= MAXIMUM_RANGE or hit then
						KillUnit(temp.missile)
						DestroyEffect(temp.fx)
						db[index] = db[dbIndex]
						dbIndex = dbIndex - 1
						index = index -1
						destroy temp
						if dbIndex== -1 then
							PauseTimer(clock)
						end
					end
				end
				index = index+1
			endloop
		end

		static function c takes nothing returns nothing
			unit targ
			unit tU
			Missile temp
			real face
			real cX
			real cY
			real tX
			real tY
			player owner
			if GetSpellAbilityId()== ARRAY_ID then
				targ = GetSpellTargetUnit()
				tU = GetTriggerUnit()
				cX= GetUnitX(tU)
				cY= GetUnitY(tU)
				Sounds.play3D(SOUND, 1., cX, cY, 100.)
				if targ!= null then
					tU= GetTriggerUnit()
					owner = GetOwningPlayer(tU)
					cX= GetUnitX(tU)
					cY= GetUnitY(tU)
					face = Atan2(GetUnitY(targ)-cY, GetUnitX(targ)-cX)
					temp = new Missile
					temp.target = targ
					temp.missile = CreateUnit(GetOwningPlayer(tU), DUMMY_ID, cX, cY, face*bj_RADTODEG)
					SetUnitX(temp.missile, cX+INITIAL_OFFSET*Cos(face+bj_PI/2.))
					SetUnitY(temp.missile, cY+INITIAL_OFFSET*Sin(face+bj_PI/2.))
					UnitAddAbility(temp.missile, 'Arav')
					UnitAddAbility(temp.missile, 'Aloc')
					SetUnitFlyHeight(temp.missile, FLY_HEIGHT, 0.)
					SetUnitScale(temp.missile, SCALE, SCALE, SCALE)
					temp.fx = AddSpecialEffectTarget(MISSILE_MODEL, temp.missile, "origin")
					temp.vel = INITIAL_VELOCITY * CLOCK_PERIOD
					temp.dX = INITIAL_VELOCITY * Cos(face) * CLOCK_PERIOD
					temp.dY = INITIAL_VELOCITY * Sin(face) * CLOCK_PERIOD
					temp.ownerID = GetPlayerId(owner)
					dbIndex = dbIndex + 1
					db[dbIndex] = temp
					if dbIndex== 0 then
						TimerStart(clock, CLOCK_PERIOD, true, function p)
					end
					temp = new Missile
					temp.target = targ
					temp.missile = CreateUnit(GetOwningPlayer(tU), DUMMY_ID, cX, cY, face*bj_RADTODEG)
					SetUnitX(temp.missile, cX+INITIAL_OFFSET*Cos(face-bj_PI/2.))
					SetUnitY(temp.missile, cY+INITIAL_OFFSET*Sin(face-bj_PI/2.))
					UnitAddAbility(temp.missile, 'Arav')
					UnitAddAbility(temp.missile, 'Aloc')
					SetUnitFlyHeight(temp.missile, FLY_HEIGHT, 0.)
					SetUnitScale(temp.missile, SCALE, SCALE, SCALE)
					temp.fx = AddSpecialEffectTarget(MISSILE_MODEL, temp.missile, "origin")
					temp.vel = INITIAL_VELOCITY * CLOCK_PERIOD
					temp.dX = INITIAL_VELOCITY * Cos(face) * CLOCK_PERIOD
					temp.dY = INITIAL_VELOCITY * Sin(face) * CLOCK_PERIOD
					temp.ownerID = GetPlayerId(owner)
					dbIndex = dbIndex+1
					db[dbIndex] = temp
				else
					tU= GetTriggerUnit()
					owner = GetOwningPlayer(tU)
					cX= GetUnitX(tU)
					cY= GetUnitY(tU)
					tX= GetSpellTargetX()
					tY= GetSpellTargetY()
					face = Atan2(tY-cY, tX-cX)
					temp = new Missile
					temp.target = null
					temp.missile = CreateUnit(GetOwningPlayer(tU), DUMMY_ID, cX, cY, face*bj_RADTODEG)
					SetUnitX(temp.missile, cX+INITIAL_OFFSET*Cos(face+bj_PI/2.))
					SetUnitY(temp.missile, cY+INITIAL_OFFSET*Sin(face+bj_PI/2.))
					UnitAddAbility(temp.missile, 'Arav')
					UnitAddAbility(temp.missile, 'Aloc')
					SetUnitFlyHeight(temp.missile, FLY_HEIGHT, 0.)
					SetUnitScale(temp.missile, SCALE, SCALE, SCALE)
					temp.fx = AddSpecialEffectTarget(MISSILE_MODEL, temp.missile, "origin")
					temp.vel = INITIAL_VELOCITY * CLOCK_PERIOD
					temp.dX = INITIAL_VELOCITY * Cos(face) * CLOCK_PERIOD
					temp.dY = INITIAL_VELOCITY * Sin(face) * CLOCK_PERIOD
					temp.ddX = ACCELERATION * Cos(face) * CLOCK_PERIOD
					temp.ddY = ACCELERATION * Sin(face) * CLOCK_PERIOD
					temp.ownerID = GetPlayerId(owner)
					dbIndex = dbIndex + 1
					db[dbIndex] = temp
					if dbIndex== 0 then
						TimerStart(clock, CLOCK_PERIOD, true, function p)
					end
					temp = new Missile
					temp.target = null
					temp.missile = CreateUnit(GetOwningPlayer(tU), DUMMY_ID, cX, cY, face*bj_RADTODEG)
					SetUnitX(temp.missile, cX+INITIAL_OFFSET*Cos(face-bj_PI/2.))
					SetUnitY(temp.missile, cY+INITIAL_OFFSET*Sin(face-bj_PI/2.))
					UnitAddAbility(temp.missile, 'Arav')
					UnitAddAbility(temp.missile, 'Aloc')
					SetUnitFlyHeight(temp.missile, FLY_HEIGHT, 0.)
					SetUnitScale(temp.missile, SCALE, SCALE, SCALE)
					temp.fx = AddSpecialEffectTarget(MISSILE_MODEL, temp.missile, "origin")
					temp.vel = INITIAL_VELOCITY * CLOCK_PERIOD
					temp.dX = INITIAL_VELOCITY * Cos(face) * CLOCK_PERIOD
					temp.dY = INITIAL_VELOCITY * Sin(face) * CLOCK_PERIOD
					temp.ddX = ACCELERATION * Cos(face) * CLOCK_PERIOD
					temp.ddY = ACCELERATION * Sin(face) * CLOCK_PERIOD
					temp.ownerID = GetPlayerId(owner)
					dbIndex = dbIndex+1
					db[dbIndex] = temp
				end
				if not ht.hasInt(tU.getHandleId()) then
					ht.saveInt(tU.getHandleId(), 0)
				end
				ht.saveInt(tU.getHandleId(), ht.loadInt(tU.getHandleId()) + 1)
				if ht.loadInt(tU.getHandleId()) == 1 then
					UnitRemoveAbility(tU, ARRAY_ID)
					UnitAddAbility(tU, ARRAY_ID)
				else
					ht.saveInt(tU.getHandleId(), 0)
				end
			end
		end
	end

	init
		registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_EFFECT, function DTS12MissileArray.c)
		DTS12MissileArray.ht = new Table
		doAfter(1.0, () -> Sounds.preload(DTS12MissileArray.SOUND))
	end

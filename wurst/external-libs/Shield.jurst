
//*     *API*
//* real TIMER_PERIOD:      This value refers to how often Shield should search
//*                         for instances that are expired in regards to their
//*                         duration. A smaller value means that shields are less
//*                         likely to block damage when their duration has passed,
//*                         while a larger value is less computationally expensive.
//*                         A good value lies on [1./60., 1./2.].
//* static method add:      This is the one and only important method for
//*                         instanciating a Shield. The arguments are of the
//*                         form (unit u, real a, real t, string f, string p)
//*                         which imparts a shield of size 'a' for time 't' on
//*                         'u' using effect with model 'f' on attachment
//*                         point 'p'.
package Shield
	import DamageType
	import StructuredDD

	//* We must declare the UnitAlive native because StructuredDD no longer
	//* declares it for us :) UnitAlive is proven to have less computational
	//* cost compared to IsUnitType(u, UNIT_TYPE_DEAD)
	native UnitAlive takes unit u returns boolean

	//* This struct is just a shim for a pretty API. (You don't instanciate
	//* Shield objects yourself)
	public class Shield
		//< BEGIN CUSTOMIZABLE SECTION

		//* How often to check for shield instances with expired durations. A
		//* smaller value will reduce the likelihood of a unit blocking damage
		//* with a shield that would otherwise be expired, at the cost of
		//* performance. A good value is between 1./30. and 1./2.
		private static constant real TIMER_PERIOD = 1./10.

		//> END CUSTOMIZABLE SECTION

		private static Shield array allShields
		private static integer shieldIndex = -1
		private static timer time = CreateTimer()
		static Table tab

		private boolean useDuration = true
		private boolean finiteShield = true
		private unit u
		private real shieldLeft
		private real falseHP
		private real timeLeft
		private effect fx
		private Shield prevShield = null
		private Shield nextShield = null

		//* This method is used for handling when a unit with a shield
		//* receives damage.
		static method handler takes nothing returns nothing
			Shield tempDat
			Shield destroyingDat
			unit tU = GetTriggerUnit()
			real damageLeft = GetEventDamage()
			boolean noShieldsLeft = false
			if DamageType.get() != DamageType.SPELL and UnitAlive(tU) and tab.hasInt(tU.getHandleId()) then
				tempDat = Shield.tab.loadInt(tU.getHandleId()) castTo Shield
				//we need to loop until either all the damage is mitigated
				//or there's no shield left on this unit.
				loop
					exitwhen damageLeft <= 0. or noShieldsLeft
					if tempDat.shieldLeft>damageLeft then
						if tempDat.finiteShield then
							tempDat.shieldLeft = tempDat.shieldLeft-damageLeft
						end
						SetWidgetLife(tempDat.u, GetWidgetLife(tempDat.u)+damageLeft)
						damageLeft = 0.
					else
						damageLeft = damageLeft-tempDat.shieldLeft
						SetWidgetLife(tempDat.u, GetWidgetLife(tempDat.u)+tempDat.shieldLeft)
						tempDat.shieldLeft = 0.
						if tempDat.falseHP>damageLeft then
							tempDat.falseHP = tempDat.falseHP-damageLeft
							damageLeft = 0.
						else
							damageLeft = damageLeft-tempDat.falseHP
							tempDat.falseHP = 0.
							destroyingDat = tempDat
							if destroyingDat.nextShield != null then
								tempDat = destroyingDat.nextShield
								tempDat.prevShield = null
								Shield.tab.saveInt(tempDat.u.getHandleId(), tempDat castTo int)
							else
								noShieldsLeft = true
							end
							destroyingDat.nextShield = null
						end
					end
				end
			end
		end

		//* This method runs every TIMER_PERIOD seconds as long as the stack
		//* is not empty, and looks for members that need to be destroyed.
		private static method timeout takes nothing returns nothing
			integer index = 0
			Shield tempDat
			Shield otherDat
			loop
				exitwhen index>Shield.shieldIndex
				tempDat = Shield.allShields[index]
				tempDat.timeLeft = tempDat.timeLeft-TIMER_PERIOD
				if (tempDat.timeLeft <= 0. and tempDat.useDuration) or (tempDat.shieldLeft+tempDat.falseHP) <= 0. or UnitAlive(tempDat.u) == false then
					//deallocate it, depending on the values of prevShield
					//and nextShield
					if tempDat.prevShield == null and tempDat.nextShield == null and Shield.tab.loadInt(tempDat.u.getHandleId()) == tempDat castTo int then
						//this was the only shield left on the unit so:
						Shield.tab.removeInt(tempDat.u.getHandleId())
					elseif tempDat.prevShield == null and tempDat.nextShield != null then
						//the shield was the first in a list so we have to
						//make next into the new first!
						otherDat = tempDat.nextShield
						otherDat.prevShield = null
						Shield.tab.saveInt(tempDat.u.getHandleId(), otherDat castTo int)
					elseif tempDat.prevShield != null and tempDat.nextShield == null then
						//the shield was the end of the list so let's do the
						//proper changes to the previous member.
						otherDat = tempDat.prevShield
						otherDat.nextShield = null
					elseif tempDat.prevShield != null and tempDat.nextShield != null then
						//this shield was somewhere in the middle of the list
						//so let's make the prev and next link to each other
						otherDat = tempDat.prevShield
						otherDat.nextShield = tempDat.nextShield
						otherDat = tempDat.nextShield
						otherDat.prevShield = tempDat.prevShield
					end
					//let's reset the unit's hp if he has extra
					if tempDat.falseHP>0. then
						SetWidgetLife(tempDat.u, GetWidgetLife(tempDat.u)-tempDat.falseHP)
					end
					DestroyEffect(tempDat.fx)
					destroy tempDat
					Shield.allShields[index] = Shield.allShields[Shield.shieldIndex]
					Shield.shieldIndex = Shield.shieldIndex-1
					index = index-1
					if Shield.shieldIndex == -1 then
						PauseTimer(Shield.time)
					end
				end
				index = index+1
			end
		end

		//* This method adds a shield to a unit. You can use
		//* Shield.DEFAULT_EFFECT in the fx argument.
		static method add takes unit u, real amount, real time, string fx, string fxpoint returns nothing
			Shield tempDat = new Shield
			Shield linkedDat
			real initialLife = GetWidgetLife(u)
			real maxLife = GetUnitState(u, UNIT_STATE_MAX_LIFE)
			real diff = maxLife-initialLife
			tempDat.u = u
			tempDat.timeLeft = time
			tempDat.fx = AddSpecialEffectTarget(fx, u, fxpoint)
			if time == -1. then
				tempDat.useDuration = false
			end
			if amount == -1. then
				amount = 100000.
				tempDat.finiteShield = false
			end
			//figure out how to partition the damage
			if diff >= amount then
				//the unit has plenty of missing HP, so:
				tempDat.shieldLeft = 0
				tempDat.falseHP = amount
				SetWidgetLife(u, initialLife+amount)
			else
				//the unit has less hp missing than the shield has value, so:
				SetWidgetLife(u, maxLife)
				tempDat.falseHP = diff
				tempDat.shieldLeft = amount-diff
			end
			//Now let's figure out if the unit already has a shield - if he
			//does, we add this shield to the front:
			if Shield.tab.hasInt(u.getHandleId()) then
				linkedDat = Shield.tab.loadInt(u.getHandleId()) castTo Shield
				tempDat.nextShield = linkedDat
				linkedDat.prevShield = tempDat
			end
			Shield.tab.saveInt(u.getHandleId(), tempDat castTo int)
			//now let's add this shield to the stack so it can be properly
			//deallocated when its time runs out:
			Shield.shieldIndex = Shield.shieldIndex+1
			Shield.allShields[Shield.shieldIndex] = tempDat
			//if allShields was previously empty we have to jumpstart the timer:
			if Shield.shieldIndex == 0 then
				TimerStart(Shield.time, Shield.TIMER_PERIOD, true, function Shield.timeout)
			end
		end
	end

	init
		Shield.tab = new Table
		StructuredDD.addHandler(function Shield.handler)
	end

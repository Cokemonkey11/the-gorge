
//*     *API*
//* real TIMER_PERIOD:      This value refers to how often Shield should search
//*                         for instances that are expired in regards to their
//*                         duration. A smaller value means that shields are less
//*                         likely to block damage when their duration has passed,
//*                         while a larger value is less computationally expensive.
//*                         A good value lies on [1./60., 1./2.].
//* static method add:      This is the one and only important method for
//*                         instanciating a Shield. The arguments are of the
//*                         form (unit u, real a, real t, string f, string p)
//*                         which imparts a shield of size 'a' for time 't' on
//*                         'u' using effect with model 'f' on attachment
//*                         point 'p'.
package Shield
	import DamageType
	import StructuredDD

	//* We must declare the UnitAlive native because StructuredDD no longer
	//* declares it for us :) UnitAlive is proven to have less computational
	//* cost compared to IsUnitType(u, UNIT_TYPE_DEAD)
	native UnitAlive takes unit u returns bool

	//* This struct is just a shim for a pretty API. (You don't instanciate
	//* Shield objects yourself)
	public class Shield
		//< BEGIN CUSTOMIZABLE SECTION

		//* How often to check for shield instances with expired durations. A
		//* smaller value will reduce the likelihood of a unit blocking damage
		//* with a shield that would otherwise be expired, at the cost of
		//* performance. A good value is between 1./30. and 1./2.
		private static constant real TIMER_PERIOD= 1./10.

		//> END CUSTOMIZABLE SECTION

		private static Shield array allShields
		private static int shieldIndex= -1
		private static timer time= CreateTimer()
		static Table tab

		private bool useDuration= true
		private bool finiteShield= true
		private unit u
		private real shieldLeft
		private real falseHP
		private real timeLeft
		private effect fx
		private Shield prevShield = null
		private Shield nextShield = null

		//* This method is used for handling when a unit with a shield
		//* receives damage.
		static method handler takes nothing returns nothing
			Shield tempDat
			Shield destroyingDat
			unit tU= GetTriggerUnit()
			real damageLeft= GetEventDamage()
			bool noShieldsLeft= false
			if DamageType.get()!= DamageType.SPELL and UnitAlive(tU) and tab.hasInt(tU.getHandleId()) then
				tempDat= Shield.tab.loadInt(tU.getHandleId()) castTo Shield
				//we need to loop until either all the damage is mitigated
				//or there's no shield left on this unit.
				loop
					exitwhen damageLeft<= 0. or noShieldsLeft
					if tempDat.shieldLeft>damageLeft then
						if tempDat.finiteShield then
							tempDat.shieldLeft= tempDat.shieldLeft-damageLeft
						end
						SetWidgetLife(tempDat.u, GetWidgetLife(tempDat.u)+damageLeft)
						damageLeft= 0.
					else
						damageLeft= damageLeft-tempDat.shieldLeft
						SetWidgetLife(tempDat.u, GetWidgetLife(tempDat.u)+tempDat.shieldLeft)
						tempDat.shieldLeft= 0.
						if tempDat.falseHP>damageLeft then
							tempDat.falseHP= tempDat.falseHP-damageLeft
							damageLeft= 0.
						else
							damageLeft= damageLeft-tempDat.falseHP
							tempDat.falseHP= 0.
							destroyingDat= tempDat
							if destroyingDat.nextShield != null then
								tempDat= destroyingDat.nextShield
								tempDat.prevShield = null
								Shield.tab.saveInt(tempDat.u.getHandleId(), tempDat castTo int)
							else
								noShieldsLeft= true
							end
							destroyingDat.nextShield = null
						end
					end
				end
			end
		end

		//* This method runs every TIMER_PERIOD seconds as long as the stack
		//* is not empty, and looks for members that need to be destroyed.
		private static method timeout takes nothing returns nothing
			int index= 0
			Shield tempDat
			Shield otherDat
			loop
				exitwhen index>Shield.shieldIndex
				tempDat= Shield.allShields[index]
				tempDat.timeLeft= tempDat.timeLeft-TIMER_PERIOD
				if (tempDat.timeLeft<= 0. and tempDat.useDuration) or (tempDat.shieldLeft+tempDat.falseHP)<= 0. or UnitAlive(tempDat.u)== false then
					//deallocate it, depending on the values of prevShield
					//and nextShield
					if tempDat.prevShield == null and tempDat.nextShield == null and Shield.tab.loadInt(tempDat.u.getHandleId()) == tempDat castTo int then
						//this was the only shield left on the unit so:
						Shield.tab.removeInt(tempDat.u.getHandleId())
					elseif tempDat.prevShield == null and tempDat.nextShield != null then
						//the shield was the first in a list so we have to
						//make next into the new first!
						otherDat= tempDat.nextShield
						otherDat.prevShield= null
						Shield.tab.saveInt(tempDat.u.getHandleId(), otherDat castTo int)
					elseif tempDat.prevShield != null and tempDat.nextShield == null then
						//the shield was the end of the list so let's do the
						//proper changes to the previous member.
						otherDat= tempDat.prevShield
						otherDat.nextShield = null
					elseif tempDat.prevShield != null and tempDat.nextShield != null then
						//this shield was somewhere in the middle of the list
						//so let's make the prev and next link to each other
						otherDat= tempDat.prevShield
						otherDat.nextShield= tempDat.nextShield
						otherDat= tempDat.nextShield
						otherDat.prevShield= tempDat.prevShield
					end
					//let's reset the unit's hp if he has extra
					if tempDat.falseHP>0. then
						SetWidgetLife(tempDat.u, GetWidgetLife(tempDat.u)-tempDat.falseHP)
					end
					DestroyEffect(tempDat.fx)
					destroy tempDat
					Shield.allShields[index]= Shield.allShields[Shield.shieldIndex]
					Shield.shieldIndex= Shield.shieldIndex-1
					index= index-1
					if Shield.shieldIndex== -1 then
						PauseTimer(Shield.time)
					end
				end
				index= index+1
			end
		end

		//* This method adds a shield to a unit. You can use
		//* Shield.DEFAULT_EFFECT in the fx argument.
		static method add takes unit u, real amount, real time, string fx, string fxpoint returns nothing
			Shield tempDat= new Shield
			Shield linkedDat
			real initialLife= GetWidgetLife(u)
			real maxLife= GetUnitState(u, UNIT_STATE_MAX_LIFE)
			real diff= maxLife-initialLife
			tempDat.u= u
			tempDat.timeLeft= time
			tempDat.fx= AddSpecialEffectTarget(fx, u, fxpoint)
			if time== -1. then
				tempDat.useDuration= false
			end
			if amount== -1. then
				amount= 100000.
				tempDat.finiteShield= false
			end
			//figure out how to partition the damage
			if diff>= amount then
				//the unit has plenty of missing HP, so:
				tempDat.shieldLeft= 0
				tempDat.falseHP= amount
				SetWidgetLife(u, initialLife+amount)
			else
				//the unit has less hp missing than the shield has value, so:
				SetWidgetLife(u, maxLife)
				tempDat.falseHP= diff
				tempDat.shieldLeft= amount-diff
			end
			//Now let's figure out if the unit already has a shield - if he
			//does, we add this shield to the front:
			if Shield.tab.hasInt(u.getHandleId()) then
				linkedDat= Shield.tab.loadInt(u.getHandleId()) castTo Shield
				tempDat.nextShield= linkedDat
				linkedDat.prevShield= tempDat
			end
			Shield.tab.saveInt(u.getHandleId(), tempDat castTo int)
			//now let's add this shield to the stack so it can be properly
			//deallocated when its time runs out:
			Shield.shieldIndex= Shield.shieldIndex+1
			Shield.allShields[Shield.shieldIndex]= tempDat
			//if allShields was previously empty we have to jumpstart the timer:
			if Shield.shieldIndex== 0 then
				TimerStart(Shield.time, Shield.TIMER_PERIOD, true, function Shield.timeout)
			end
		end
	end

	init
		Shield.tab = new Table
		StructuredDD.addHandler(function Shield.handler)
	end
